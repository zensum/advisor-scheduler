(function (_, Kotlin) {
  'use strict';
  var toMutableList = Kotlin.kotlin.collections.toMutableList_4c7yge$;
  var sum = Kotlin.kotlin.collections.sum_plj8ka$;
  var sum_0 = Kotlin.kotlin.collections.sum_lvsncp$;
  function assignApplications(applications, advisors) {
    var tmp$;
    reassignApplications(applications, advisors);
    var unassigned = toMutableList(applications);
    tmp$ = applications.iterator();
    while (tmp$.hasNext()) {
      var app = tmp$.next();
      app.slot.desiredApplicationsPerAdvisor = calcDesiredApplicationsPerAdvisor(app.slot, advisors, unassigned);
      var $receiver = getAdvisorsHavingSlot(app.slot, advisors);
      var minBy$result;
      minBy$break: do {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext()) {
          minBy$result = null;
          break minBy$break;
        }
        var minElem = iterator.next();
        var minValue = calcSlotScore(app.slot, minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = calcSlotScore(app.slot, e);
          if (Kotlin.compareTo(minValue, v) > 0) {
            minElem = e;
            minValue = v;
          }
        }
        minBy$result = minElem;
      }
       while (false);
      var advisor = minBy$result;
      if (advisor != null) {
        advisor.applications.add_11rb$(app);
        unassigned.remove_11rb$(app);
      }
    }
  }
  function reassignApplications(applications, advisors) {
    var tmp$;
    tmp$ = advisors.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
      var tmp$_0;
      tmp$_0 = applications.iterator();
      while (tmp$_0.hasNext()) {
        var element_0 = tmp$_0.next();
        if (Kotlin.equals(element_0.advisor_id, element.id))
          destination.add_11rb$(element_0);
      }
      var apps = destination;
      element.applications.addAll_brywnq$(apps);
      applications.removeAll_brywnq$(apps);
    }
  }
  function hasSlot(advisor, slot) {
    var $receiver = advisor.slots;
    var any$result;
    any$break: do {
      var tmp$;
      tmp$ = $receiver.iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        if (Kotlin.equals(element.time, slot.time)) {
          any$result = true;
          break any$break;
        }
      }
      any$result = false;
    }
     while (false);
    return any$result;
  }
  function getAdvisorsHavingSlot(slot, advisors) {
    var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
    var tmp$;
    tmp$ = advisors.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      if (hasSlot(element, slot))
        destination.add_11rb$(element);
    }
    return destination;
  }
  function getAppsInSlot(slot, advisor) {
    return getAppsInSlot_1(slot, advisor.applications);
  }
  function getAppsInSlot_0(slot, advisors) {
    var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
    var tmp$;
    tmp$ = advisors.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      var list = getAppsInSlot_1(slot, element.applications);
      Kotlin.kotlin.collections.addAll_ipc267$(destination, list);
    }
    return destination;
  }
  function getAppsInSlot_1(slot, applications) {
    var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
    var tmp$;
    tmp$ = applications.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      if (Kotlin.equals(element.slot, slot))
        destination.add_11rb$(element);
    }
    return destination;
  }
  function countAppsInSlot(slot, advisor) {
    return countAppsInSlot_1(slot, advisor.applications);
  }
  function countAppsInSlot_0(slot, advisors) {
    var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$(Kotlin.kotlin.collections.collectionSizeOrDefault_ba2ldo$(advisors, 10));
    var tmp$;
    tmp$ = advisors.iterator();
    while (tmp$.hasNext()) {
      var item = tmp$.next();
      destination.add_11rb$(countAppsInSlot_1(slot, item.applications));
    }
    return sum(destination);
  }
  function countAppsInSlot_1(slot, applications) {
    var tmp$;
    var count = 0;
    tmp$ = applications.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      if (Kotlin.equals(element.slot, slot)) {
        count = count + 1 | 0;
      }
    }
    return count;
  }
  function calcDesiredApplicationsPerAdvisor(slot, advisors, unassignedApps) {
    var assignableAdvisors = getAdvisorsToAssignTo(slot, advisors, unassignedApps);
    return (countAppsInSlot_1(slot, unassignedApps) + countAppsInSlot_0(slot, assignableAdvisors) | 0) / assignableAdvisors.size;
  }
  function getAdvisorsToAssignTo(slot, advisors, unassignedApps) {
    var unassigned = getAppsInSlot_1(slot, unassignedApps);
    if (unassigned.size === 0) {
      return Kotlin.kotlin.collections.emptyList_287e2$();
    }
    var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
    var tmp$;
    tmp$ = advisors.iterator();
    while (tmp$.hasNext()) {
      var element = tmp$.next();
      if (hasSlot(element, slot))
        destination.add_11rb$(element);
    }
    var assignableAdvisors = toMutableList(destination);
    var assigned = getAppsInSlot_0(slot, assignableAdvisors);
    var countedAppsInSlot = {v: assigned.size + unassigned.size | 0};
    do {
      var destination_0 = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
      var tmp$_0;
      tmp$_0 = assignableAdvisors.iterator();
      while (tmp$_0.hasNext()) {
        var element_0 = tmp$_0.next();
        if (countAppsInSlot(slot, element_0) > (countedAppsInSlot.v / assignableAdvisors.size | 0))
          destination_0.add_11rb$(element_0);
      }
      var advisorsToRemove = destination_0;
      assignableAdvisors.removeAll_brywnq$(advisorsToRemove);
      countedAppsInSlot.v = countedAppsInSlot.v - countAppsInSlot_0(slot, advisorsToRemove) | 0;
    }
     while (advisorsToRemove.size > 0);
    return assignableAdvisors;
  }
  function calcSlotScore(slot, advisor) {
    return (countAppsInSlot(slot, advisor) * 1000 | 0) + predictAvgBooks(advisor);
  }
  function predictAvgBooks(advisor) {
    var tmp$ = 1 / advisor.slots.size | 0;
    var $receiver = advisor.slots;
    var destination = Kotlin.kotlin.collections.ArrayList_init_ww73n8$(Kotlin.kotlin.collections.collectionSizeOrDefault_ba2ldo$($receiver, 10));
    var tmp$_0;
    tmp$_0 = $receiver.iterator();
    while (tmp$_0.hasNext()) {
      var item = tmp$_0.next();
      destination.add_11rb$(Math.max(item.desiredApplicationsPerAdvisor, countAppsInSlot(item, advisor)));
    }
    return tmp$ * sum_0(destination);
  }
  function Advisor(id, applications, slots) {
    if (applications === void 0) {
      applications = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
    }
    if (slots === void 0) {
      slots = Kotlin.kotlin.collections.emptyList_287e2$();
    }
    this.id = id;
    this.applications = applications;
    this.slots = slots;
  }
  Advisor.$metadata$ = {
    kind: Kotlin.Kind.CLASS,
    simpleName: 'Advisor',
    interfaces: []
  };
  Advisor.prototype.component1 = function () {
    return this.id;
  };
  Advisor.prototype.component2 = function () {
    return this.applications;
  };
  Advisor.prototype.component3 = function () {
    return this.slots;
  };
  Advisor.prototype.copy_208ced$ = function (id, applications, slots) {
    return new Advisor(id === void 0 ? this.id : id, applications === void 0 ? this.applications : applications, slots === void 0 ? this.slots : slots);
  };
  Advisor.prototype.toString = function () {
    return 'Advisor(id=' + Kotlin.toString(this.id) + (', applications=' + Kotlin.toString(this.applications)) + (', slots=' + Kotlin.toString(this.slots)) + ')';
  };
  Advisor.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.id) | 0;
    result = result * 31 + Kotlin.hashCode(this.applications) | 0;
    result = result * 31 + Kotlin.hashCode(this.slots) | 0;
    return result;
  };
  Advisor.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.id, other.id) && Kotlin.equals(this.applications, other.applications) && Kotlin.equals(this.slots, other.slots)))));
  };
  function Application(id, advisor_id, slot) {
    if (id === void 0)
      id = '';
    if (advisor_id === void 0)
      advisor_id = '';
    this.id = id;
    this.advisor_id = advisor_id;
    this.slot = slot;
  }
  Application.$metadata$ = {
    kind: Kotlin.Kind.CLASS,
    simpleName: 'Application',
    interfaces: []
  };
  Application.prototype.component1 = function () {
    return this.id;
  };
  Application.prototype.component2 = function () {
    return this.advisor_id;
  };
  Application.prototype.component3 = function () {
    return this.slot;
  };
  Application.prototype.copy_uo2nvv$ = function (id, advisor_id, slot) {
    return new Application(id === void 0 ? this.id : id, advisor_id === void 0 ? this.advisor_id : advisor_id, slot === void 0 ? this.slot : slot);
  };
  Application.prototype.toString = function () {
    return 'Application(id=' + Kotlin.toString(this.id) + (', advisor_id=' + Kotlin.toString(this.advisor_id)) + (', slot=' + Kotlin.toString(this.slot)) + ')';
  };
  Application.prototype.hashCode = function () {
    var result = 0;
    result = result * 31 + Kotlin.hashCode(this.id) | 0;
    result = result * 31 + Kotlin.hashCode(this.advisor_id) | 0;
    result = result * 31 + Kotlin.hashCode(this.slot) | 0;
    return result;
  };
  Application.prototype.equals = function (other) {
    return this === other || (other !== null && (typeof other === 'object' && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.id, other.id) && Kotlin.equals(this.advisor_id, other.advisor_id) && Kotlin.equals(this.slot, other.slot)))));
  };
  function Slot() {
    Slot$Factory_getInstance();
    this.time = null;
    this.desiredApplicationsPerAdvisor = 0.0;
  }
  function Slot$Factory() {
    Slot$Factory_instance = this;
    this.slots_0 = Kotlin.kotlin.collections.ArrayList_init_ww73n8$();
  }
  Slot$Factory.prototype.get_61zpoe$ = function (time) {
    var $receiver = this.slots_0;
    var firstOrNull_6jwkkr$result;
    firstOrNull_6jwkkr$break: do {
      var tmp$;
      tmp$ = $receiver.iterator();
      while (tmp$.hasNext()) {
        var element = tmp$.next();
        if (Kotlin.equals(time, element.time)) {
          firstOrNull_6jwkkr$result = element;
          break firstOrNull_6jwkkr$break;
        }
      }
      firstOrNull_6jwkkr$result = null;
    }
     while (false);
    var slot = firstOrNull_6jwkkr$result;
    if (slot == null) {
      slot = Slot_init(time);
      this.slots_0.add_11rb$(slot);
    }
    return slot;
  };
  Slot$Factory.$metadata$ = {
    kind: Kotlin.Kind.OBJECT,
    simpleName: 'Factory',
    interfaces: []
  };
  var Slot$Factory_instance = null;
  function Slot$Factory_getInstance() {
    if (Slot$Factory_instance === null) {
      new Slot$Factory();
    }
    return Slot$Factory_instance;
  }
  Slot.$metadata$ = {
    kind: Kotlin.Kind.CLASS,
    simpleName: 'Slot',
    interfaces: []
  };
  function Slot_init(time, $this) {
    $this = $this || Object.create(Slot.prototype);
    Slot.call($this);
    $this.time = time;
    return $this;
  }
  var package$se = _.se || (_.se = {});
  var package$zensum = package$se.zensum || (package$se.zensum = {});
  var package$advisorScheduler = package$zensum.advisorScheduler || (package$zensum.advisorScheduler = {});
  package$advisorScheduler.assignApplications = assignApplications;
  package$advisorScheduler.reassignApplications_vsqs3r$ = reassignApplications;
  package$advisorScheduler.hasSlot_owtt3i$ = hasSlot;
  package$advisorScheduler.getAdvisorsHavingSlot_639t15$ = getAdvisorsHavingSlot;
  package$advisorScheduler.getAppsInSlot_68z2ho$ = getAppsInSlot;
  package$advisorScheduler.getAppsInSlot_639t15$ = getAppsInSlot_0;
  package$advisorScheduler.getAppsInSlot_jluyw9$ = getAppsInSlot_1;
  package$advisorScheduler.countAppsInSlot_68z2ho$ = countAppsInSlot;
  package$advisorScheduler.countAppsInSlot_639t15$ = countAppsInSlot_0;
  package$advisorScheduler.countAppsInSlot_jluyw9$ = countAppsInSlot_1;
  package$advisorScheduler.calcDesiredApplicationsPerAdvisor_pli16f$ = calcDesiredApplicationsPerAdvisor;
  package$advisorScheduler.getAdvisorsToAssignTo_pli16f$ = getAdvisorsToAssignTo;
  package$advisorScheduler.calcSlotScore_68z2ho$ = calcSlotScore;
  package$advisorScheduler.predictAvgBooks_u75gvd$ = predictAvgBooks;
  package$advisorScheduler.Advisor = Advisor;
  package$advisorScheduler.Application = Application;
  Object.defineProperty(Slot, 'Factory', {
    get: Slot$Factory_getInstance
  });
  package$advisorScheduler.Slot = Slot;
  Kotlin.defineModule('advisor-scheduler_main', _);
  return _;
}(module.exports, require('kotlin')));
